;**********************************************************************;
;                                                                      ;
;   This file is part of RSX180, a multi-tasking OS for the Z180.      ;
;   Copyright (C) 1985-2023, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

	NAME	('TSKMGR')
	TITLE	'RSX180 Task Management'

;----------------------------------------------------------------------;
;                                                                      ;
;	Task management routines.                                      ;
;                                                                      ;
;----------------------------------------------------------------------;

	.Z80

; Note: compile with ZSM4 (M80 reverses chars in 'CO', etc.)

	include	SYSCONF.INC
	include	TCB.INC
	include	PCB.INC
	include	DCB.INC
	include	LCB.INC
	include	AST.INC
	include	CLKQ.INC
	include	SYSFN.INC
	include	ERRORS.INC

	cseg

	public	DSPTCH		; dispatch next ready task
	public	DECCT		; decrement interval counters
	public	GO		; initial system start
	public	$LKTCB		; link TCB to a list
	public	INITKM		; initialize task manager
	public	$FNTSK		; find task by name
	public	$FNTCB		; locate TCB in active task list
	public	FTCB		; locate TCB in the specified list
	public	ALTPRI		; change task priority
	public	TSETSV		; switch privileged task into supervisor mode
	public	TCLRSV		; switch privileged task back to user mode
	public	TRQST,TRQST2	; start (request) an installed task
	public	TKILL,TKILL2	; kill (abort) a task
	public	$REMTK		; remove a task from the STD
	public	TSTOP		; stop a task
	public	TRESUM		; resume a task
	public	$FIXTK		; fix task in memory
	public	$UNFTK		; unfix task from memory
	public	TSRUN		; start task at specified time
	public	TCSRQ		; cancel scheduled task request
	public	TCONT		; continue task execution after event
	public	TNEXT		; assign next task to partition
	public	TALLOC		; allocate task memory
	public	TFREE		; free task memory
	public	FRECMD		; free command line block
	public	EXTTSK		; extend task size
	public	CHKPRV		; check task privileges

				; Loader entry points:
	public	$LDGO		;  start task after initial load
	IF	F$CHKP
	public	$LDCKR		;  resume task after checkpoint read
	public	$LDCKW		;  queue task to partition after checkpnt write
	ENDIF

	public	$DBCON		; connect task to external debugger
	public	$DBDIS		; disconnect task from external debugger
	public	$DBBRK		; break task execution
	public	$DBRES		; resume task stopped for debugger
	public	$DBNOT		; notify debugger about debug event

	public	GETSIZ		; to be moved to pars.mac

	extrn	$TLIST,$RLIST,$WLIST,$PLIST,$FORKQ,$CLKQ,$CTCB,$CPCB
	extrn	$ERSEQ,$MVTBL,$PHYDV,$LOGDV,SFLAGS,$CPLST,$RNDC,$RNDCT
	extrn	$RNDH,$RNDL,$SWPC,$SWPCT,$SWPRI

	extrn	SYSENT,SYSSTK,SYSXIT,TICCNT,INTON,$SBANK,$UBANK,$MCOPY
	extrn	$UPUTB,DOCLKQ,DISCON,MALLOC,MFREE,$ALLOC,$FREE,CPDEHL
	extrn	CLRMEM,CLRCVL,CLNAST,UCBAR,SCBAR,IOKILL,QTKTN,QPAR
	extrn	$FNDEV,TFLAG,DOFORK,TRPFLG,CHKTRP,MEXTND,CLNCLQ,SRQST
	extrn	NEWSUB,$FNPAR,CHKPAR,$ASNTP,MCRTCB,LDRTCB,SETFLG

	if	F$HALT
	extrn	CKCLKQ
	ENDIF

;-----------------------------------------------------------------------

; Initialize task manager: init dynamic lists, queues, tables, etc.
; Called only during system startup.
;
; A number of lists are now set by VMR (or SAV SAVed from a running
; system) and therefore no longer initialized here. E.g. $TLIST, $RLIST,
; $WLIST, $PLIST, $CLKQ, $PHYDV, $LOGDV, etc.

INITKM:	xor	a
	ld	(TRPFLG),a	; clear trap flag
	ld	hl,0
	ld	($CTCB),hl	; no current TCB yet
	ld	($CPCB),hl	; no current PCB either
	ld	($CPLST),hl	; clear checkpoint partition list
	ld	($FORKQ),hl	; clear fork queue
	ld	($ERSEQ),hl	; reset error counter
	ld	($MVTBL),hl	; reset mounted volume table
	ld	a,($RNDC)
	ld	($RNDCT),a	; reset round-robin interval counter
	ld	a,($SWPC)
	ld	($SWPCT),a	; reset swap counter
	ld	hl,SFLAGS
	ld	bc,8
	call	CLRMEM		; clear system flags
	ret

;-----------------------------------------------------------------------

; Dispatch next task in ready list.

DSPTCH:	ld	hl,TFLAG
	IF	F$CHKP
	bit	2,(hl)
	jr	z,dsp0
	res	2,(hl)
	push	hl
	call	DECSWP		; time to decrement swap priorities
	call	CHKPAR
	pop	hl
dsp0:	ENDIF
	bit	1,(hl)
	jr	z,dsp1
	res	1,(hl)		; time to dispatch next task
	ld	hl,($RLIST)	; get first TCB from ready list
	ld	a,h
	or	l		; null task?
	jr	z,dsp2		; branch if yes
	push	hl
	pop	ix
	ld	iy,$RNDH	; check priority range
	ld	a,(iy)		;  for round-robin scheduling
	cp	(ix+T.PRI)
	jr	c,dsp4		; branch if priority > RNDH
	ld	a,(ix+T.PRI)
	cp	(iy+1)
	jr	c,dsp4		; branch if priority < RNDL
	ld	l,(ix+T.ACTL)	; else unlink the TCB
	ld	h,(ix+T.ACTL+1)
	ld	($RLIST),hl	; set new top TCB, IX = old TCB
	ld	iy,$RLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move old TCB to the end of its priority class
dsp1:	ld	hl,($RLIST)	; get next ready TCB
	ld	a,h
	or	l		; null task?
	jr	nz,dsp4		; dispatch it if not
dsp2:	call	DOFORK		; else dispatch fork queue...
	jr	nc,dsp2
	ld	hl,TFLAG
	bit	0,(hl)
	jr	z,dsp3
	res	0,(hl)
	push	hl
	call	DOCLKQ		; ...and clock queue
	pop	hl
dsp3:	IF	F$CHKP
	bit	2,(hl)
	IF	F$HALT
	jr	z,dsp6		; no checkpoint, continue to halt check
	ELSE
	jr	z,dsp1		; no halt? just restart loop
	ENDIF
	res	2,(hl)
	call	DECSWP		; time to decrement swap priorities
	call	CHKPAR
	ENDIF
	IF	F$HALT
dsp6:	; We just checked these, but with interrupts enabled.
	; Now atomically check them with interrupts off, and if
	; we still have nothing to do, halt.
	di
	ld	hl,($RLIST)	; TCB list
	ld	a,h
	or	l
	jr	nz,dsp5
	ld	hl,($FORKQ)	; fork queue
	ld	a,h
	or	l
	jr	nz,dsp5
	call	CKCLKQ		; clock queue
	jr	c,dsp5
	ld	a,(TFLAG)	; clock tick flags
	and	a,5
	jr	nz,dsp5
	ei			; OK, interrupts ON and quiesce CPU
	halt
	jr	dsp1		; and back around looking for activity
dsp5:	ei			; work pending, run loop again
 	ENDIF
	jr	dsp1		; loop until a task becomes ready
dsp4:	ld	($CTCB),hl	; set as current TCB
	ld	bc,T.PCB
	add	hl,bc
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	($CPCB),hl	; set current partition
	ld	bc,P.BASE
	add	hl,bc
	ld	a,(hl)
	ld	($UBANK),a
	ret

; Decrement interval counters

DECCT:	IF	F$CHKP
	ld	hl,$SWPCT
	dec	(hl)		; decrement swap interval counter
	jr	nz,dec1		; branch if not zero
	ld	a,($SWPC)
	ld	(hl),a		; else reset counter
	ld	hl,TFLAG
	set	2,(hl)		; and set flag
dec1:	ENDIF
	ld	hl,$RNDCT
	dec	(hl)		; decrement round-robin interval counter
	ret	nz		; branch if not zero
	ld	a,($RNDC)
	ld	(hl),a		; else reset counter
	ld	hl,TFLAG
	set	1,(hl)		; and set flag
	ret

	IF	F$CHKP

; Decrement the swap priority of active tasks.

; TODO: decrement swap priority only if task got CPU time during the last
; swapping interval. Reserve a status bit: bit cleared when the task is
; loaded and right after T.SPRI is decremented; bit is set by dispatcher
; after leaving the task.

DECSWP:	ld	a,($SWPRI)
	neg
	ld	c,a
	ld	de,($RLIST)
	call	decsw1
	ld	de,($WLIST)
decsw1:	ld	a,d
	or	e
	ret	z
	ld	hl,T.ST+1
	add	hl,de
	bit	T2.OUT,(hl)	; task is out of memory?
	jr	nz,decsw3	; skip it if yes
	ld	hl,T.SPRI
	add	hl,de
	ld	a,c
	cp	(hl)		; swap priority at minimum?
	jp	m,decsw2
	jp	po,decsw3
decsw2:	dec	(hl)		; decrement it if not
decsw3:	ld	hl,T.ACTL
	add	hl,de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	jr	decsw1

	ENDIF

; Start the system

GO:	call	INTON		; enable timer interrupts
	call	DSPTCH		; dispatch first ready task
	jp	SYSXIT		; go run task

;-----------------------------------------------------------------------

; Link TCB to a list, ordered by priority.

; Input:
;   IX = address of TCB to link
;   BC = offset to link field in TCB (T.LNK, T.TCBL or T.ACTL)
;   IY = head of the list to link this TCB to
; Preserves IX.

$LKTCB:	ld	e,(iy)		; get link field into DE
	ld	d,(iy+1)
	ld	a,d
	or	e		; check if zero
	jr	z,lnk2		; if yes, we reached the end of the list
	ld	hl,T.PRI
	add	hl,de
	ld	a,(hl)		; else get priority from task in chain
	cp	(ix+T.PRI)	; compare with this task's priority
	jr	c,lnk2		; jump if task with lower priority found
	push	de
	pop	iy		; else go to next item in list
	add	iy,bc
	jr	$LKTCB		; and try again

; we arrive here with:
;   IY = prev TCB +T.LNK, +T.TCBL or +T.ACTL in list, or list head ptr
;   DE = current TCB in list
;   IX = address of TCB to insert

lnk2:	push	ix		; get address of TCB to insert
	pop	hl		;  into HL
	ld	(iy),l		; set prev pointer in list
	ld	(iy+1),h
	add	hl,bc
	ld	(hl),e		; set next field on inserted TCB
	inc	hl
	ld	(hl),d
	ret

;-----------------------------------------------------------------------

; Start (request) an installed task. 

; The TCB is reset, a context block allocated and initialized, and the
; task placed in the partition wait queue. Once memory becomes availble,
; a request will be sent to the loader to load the task from disk. And
; once loaded, the TCB will be moved to the ready list, from where the
; task will be selected for execution.

; Input:
;   HL = address of task descriptor in system space, values used are:
;        - name of task to request
;        - console device
;        - user and group numbers
;        - address of command line block
;        - TA.MCR attribute
; Returns:
;   IX = task TCB address
;   CY flag set on error

; TODO:
; - use $CTCB console and session values if user did not specify a TDB

TRQST:	push	hl
	ld	bc,TD.NAME
	add	hl,bc
	ld	c,l
	ld	b,h
	call	$FNTSK		; find task by name
	pop	iy		; get TDB into IY
	ret	c		; return error if not found
	push	hl
	pop	ix		; else get TCB into IX
TRQST2:	bit	TS.ACT,(ix+T.ST); task active?
	jr	z,trq1		; jump if not
	xor	a
	bit	TA.CLI,(ix+T.ATTR) ; else check if task is a CLI
	ret	nz		   ; return success if yes
	bit	TA.ACP,(ix+T.ATTR) ; an ACP?
	ret	nz		   ; return success as well
	ld	a,E.TRUN	   ; else return error - task already active
	scf
	ret

trq1:	ld	a,(ix+T.ATTR)
	set	TA.AST,a	; enable ASTs by default
	res	TA.MCR,a
	bit	TA.MCR,(iy+TD.ATTR)
	jr	z,trq2
	set	TA.MCR,a

trq2:	ld	(ix+T.ATTR),a	; reset attributes

	ld	a,(ix+T.DPRI)
	ld	(ix+T.PRI),a	; reset priority to default

	ld	a,(ix+T.DEND)
	ld	(ix+T.END),a	; reset end address to default
	ld	a,(ix+T.DEND+1)
	ld	(ix+T.END+1),a

	xor	a
	ld	(ix+T.FLGS),a	; clear all flags
	ld	(ix+T.FLGS+1),a
	ld	(ix+T.FLGS+2),a
	ld	(ix+T.FLGS+3),a
	ld	(ix+T.WAIT),a	; clear wait-for mask
	ld	(ix+T.WAIT+1),a
	ld	(ix+T.WAIT+2),a
	ld	(ix+T.WAIT+3),a

	bit	TA.FIX,(ix+T.ATTR)
	jr	nz,trq3		; skip if task is fixed in memory
	ld	(ix+T.CTX),a	; clear context block address
	ld	(ix+T.CTX+1),a

trq3:	ld	(ix+T.CMD),a	; clear command line
	ld	(ix+T.CMD+1),a
	ld	(ix+T.RCVL),a	; clear receive list
	ld	(ix+T.RCVL+1),a
	ld	(ix+T.OCBL),a	; clear OCB list
	ld	(ix+T.OCBL+1),a
	ld	(ix+T.SAST),a	; clear specified AST list
	ld	(ix+T.SAST+1),a
	ld	(ix+T.ASTL),a	; clear AST event queue
	ld	(ix+T.ASTL+1),a
	ld	(ix+T.CPCB),a	; clear checkpoint PCB address
	ld	(ix+T.CPCB+1),a
	ld	(ix+T.IOC),a	; clear outstanding I/O count

	ld	e,(iy+TD.TI)
	ld	d,(iy+TD.TI+1)
	ld	c,(iy+TD.TI+2)
	push	ix
	push	iy
	ld	ix,($CTCB)
	call	$FNDEV
	pop	iy
	pop	ix
	ret	c
	ld	(ix+T.TI),l	; set UCB of terminal
	ld	(ix+T.TI+1),h

	bit	TA.FIX,(ix+T.ATTR) ; task fixed in memory?
	jr	nz,trq4		   ; skip memory allocation if yes

	call	GETSIZ		; compute required space
	ret	c		; return error if task too big
				; TODO: remove if TA.REM? or call TKTN?

	push	iy
	call	TALLOC		; allocate space for task
	pop	iy
	ret	c		; return error if no available memory
				; TODO: remove if TA.REM? or call TKTN?

	call	NEWCTX		; allocate and link new context block
	jr	c,trqe		; return if not enough pool memory

trq4:	call	SETCTX		; setup task context

	push	iy
	ld	iy,$WLIST
	ld	bc,T.ACTL	; insert TCB in waiting list
	call	$LKTCB		;  with T2.OUT bit set unless fixed in memory
	pop	iy

	xor	a
	set	TS.ACT,a
	ld	(ix+T.ST),a	; status = active, all other bits zero

	res	T2.ABO,(ix+T.ST+1)

	bit	TA.FIX,(ix+T.ATTR) ; task fixed in memory?
	jr	z,trq5		   ; jump if not

	bit	T2.OUT,(ix+T.ST+1) ; task already loaded?
	jr	z,$LDGO		; then start task immediately

	push	ix
	pop	hl

	xor	a		; else a load request is in progress,
	ret			;  return success

trq5:	xor	a
	set	T2.OUT,a
	ld	(ix+T.ST+1),a	; status = out of memory, all other bits clear

trq6:	push	ix
	call	QPAR		; queue the TCB to the partition wait list
	pop	ix
TNEXT:	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	ld	de,P.MAIN
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	pop	iy
	push	ix
	call	$ASNTP		; assign next task to partition
	pop	ix
	xor	a
	ret

trqe0:	; operation failed, free allocated resources and return error code

	push	af
	bit	TA.FIX,(ix+T.ATTR)
	call	z,FRECTX	; free the context block if task not fixed
	pop	af
trqe:	push	af
	bit	TA.FIX,(ix+T.ATTR)
	call	z,TFREE		; free allocated task memory
	pop	af		; return error code
	ret

; Start task execution after initial load.

$LDGO:	bit	T2.ABO,(ix+T.ST+1)
	jp	nz,TKILL2

	xor	a
	ld	(ix+T.ST+1),a	; clear all blocking bits, except TS.BPT
	bit	TS.ACT,(ix+T.ST); task active?
	ret	z		; return success if not (was a fix request)

	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	ld	de,P.BASE
	add	hl,de
	ld	a,(hl)		; get bank
	ld	c,(ix+T.EPT)
	ld	b,(ix+T.EPT+1)	; get entry point into BC
	ld	e,(ix+T.END)
	ld	d,(ix+T.END+1)	; DE = initial top of stack
;;	inc	de
	ld	hl,-22
	add	hl,de		; correct for pushed registers
	ld	(ix+T.SP),l	; set the real SP in TCB
	ld	(ix+T.SP+1),h
	ex	de,hl		; initial top of stack now in HL
	di
	ld	e,a		; dest bank in E
	dec	hl
	ld	a,b		; setup return address in task's stack
	call	$UPUTB		;  in user space
	dec	hl
	ld	a,c
	call	$UPUTB
	ei

	ld	l,(ix+T.STRT)
	ld	h,(ix+T.STRT+1)
	ld	bc,0040h
	or	a
	sbc	hl,bc		; task start below RST vector area?
	jr	c,tgo3		; yes, skip RST vector initialization

	ld	d,8
	ld	hl,0		; vector address
tgo1:	ld	bc,CHKTRP	; setup default trap handler
	call	TSETV
	ld	bc,8-2
	add	hl,bc
	dec	d
	jr	nz,tgo1

tgo3:	ld	hl,SYSRST	; vector address
	ld	bc,SYSENT	; setup syscall RST
	call	TSETV
	ld	hl,DBGRST	; vector address
	ld	bc,$KDTRP##	; setup debug RST [TODO: only for priv tasks]
	call	TSETV

tgo2:	bit	TS.BPT,(ix+T.ST); task stopped at breakpoint?
	jr	nz,tgo4		; yes, return
	push	ix
	pop	bc
	ld	iy,$WLIST
	ld	de,T.ACTL
	call	UNLTCB		; unlink TCB from wait list
	ret	c		; should not happen
	ld	iy,$RLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move task to ready list
tgo4:	xor	a
	ret

; Set jump vector in bank E at address HL to target address in BC

TSETV:	di
	ld	a,0C3h		; jp instruction code
	call	$UPUTB
	inc	hl
	ld	a,c		; target address
	call	$UPUTB
	inc	hl
	ld	a,b
	call	$UPUTB
	ei
	ret

	IF	F$CHKP

	public	UNLTCB
	extrn	FREECS

; Resume task execution after a checkpoint read.

$LDCKR:	ld	l,(ix+T.CPCB)
	ld	h,(ix+T.CPCB+1)
	xor	a
	ld	(ix+T.CPCB),a
	ld	(ix+T.CPCB+1),a
	push	hl
	ex	(sp),ix
	push	hl
	call	FREECS		; free checkpoint space
	pop	hl
	ld	de,CPCBSZ
	call	$FREE		; free checkpoint PCB
	pop	ix
	ld	a,(ix+T.ST+1)
	res	T2.OUT,a
	res	T2.CKP,a
	ld	(ix+T.ST+1),a

	bit	T2.ABO,a
	jp	nz,TKILL2

	or	a		; task became runnable?
	jp	z,tgo2		; resume task if yes
	xor	a		; else return
	ret

; Queue the task to the partition wait list after a checkpoint write

$LDCKW:	bit	T2.ABO,(ix+T.ST+1)
	jp	nz,ldcw1	; branch if task is being aborted

	set	T2.OUT,(ix+T.ST+1)

	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	push	hl
	ex	(sp),ix
	call	MFREE		; release task memory
	pop	ix
	ld	l,(ix+T.END)	; get task end address
	ld	h,(ix+T.END+1)
        call    EA2PG           ; compute required number of pages
	ld	l,(ix+T.PCB)	;  in case the task was checkpointed
	ld	h,(ix+T.PCB+1)	;   due to an extend task request
	ld	bc,P.SIZE
	add	hl,bc
	ld	(hl),a		; set new size in subpartition PCB
	jp	trq6		; queue task to partition wait list and
				;  assign released partition to next task

ldcw1:	ld	l,(ix+T.CPCB)
	ld	h,(ix+T.CPCB+1)
	xor	a
	ld	(ix+T.CPCB),a
	ld	(ix+T.CPCB+1),a
	push	hl
	ex	(sp),ix
	push	hl
	call	FREECS		; free checkpoint space
	pop	hl
	ld	de,CPCBSZ
	call	$FREE		; free checkpoint PCB
	pop	ix
	jp	TKILL2

	ENDIF

;-----------------------------------------------------------------------

; Allocate Task Context Block and link it to TCB.
; Called with IX = TCB.

NEWCTX:	ld	bc,CTXSZ	; Context Block size
	push	ix
	call	$ALLOC		; allocate new Context Block
	pop	ix
	ret	c		; return error if not enough memory
	ld	(ix+T.CTX),l	; set pointer in TCB
	ld	(ix+T.CTX+1),h
	ld	bc,CTXSZ
	call	CLRMEM		; clear block
	xor	a
	ret

; Initialize Task Context Block.
; Called with HL = addr of Context Block, IX = TCB, IY = TDB.

SETCTX:	ld	l,(ix+T.TI)	; get UCB of terminal
	ld	h,(ix+T.TI+1)
	ld	de,U.LCB
	add	hl,de
	ld	e,(hl)		; get LCB address into DE
	inc	hl
	ld	d,(hl)
	ld	l,(ix+T.CTX)	; get context address into HL
	ld	h,(ix+T.CTX+1)
	push	ix
	ld	ix,($CTCB)
	bit	TA.PRV,(ix+T.ATTR) ; is the requesting task privileged?
	jr	z,sc1		; branch if not

	xor	a
	ld	(iy+TD.USR),a	; else force session UIC
	ld	(iy+TD.GRP),a

sc1:	push	hl
	pop	ix		; IX = task context block

	xor	a
	ld	(ix+TX.XDT),a	; no external debugger attached
	ld	(ix+TX.XDT+1),a

	ld	a,(iy+TD.USR)
	or	a
	jr	nz,sc2

	ld	a,d
	or	e		; valid LCB?
	ld	a,1
	jr	z,sc2

	ld	hl,L.USR
	add	hl,de
	ld	a,(hl)

sc2:	ld	(ix+TX.UID),a	; set user ID

	ld	a,(iy+TD.GRP)
	or	a
	jr	nz,sc3

	ld	a,d
	or	e		; valid LCB?
	ld	a,1
	jr	z,sc3

	ld	hl,L.GRP
	add	hl,de
	ld	a,(hl)

sc3:	ld	(ix+TX.GID),a	; set group ID

	ld	a,d
	or	e
	jr	nz,sc4

	push	ix
	pop	hl
	ld	de,TX.DIR
	add	hl,de
	ld	bc,9
	call	CLRMEM		; clear current dir
	pop	ix		; restore TCB address
	ret

sc4:	ld	hl,L.CDIR
	add	hl,de		; src = L.CDIR field of LCB
	ex	de,hl
	push	ix
	pop	hl
	ld	bc,TX.DIR
	add	hl,bc
	ex	de,hl		; dst = TX.DIR field of context block
	ld	bc,9
	ldir			; set task's current directory
	pop	ix		; restore TCB address
	ret

;-----------------------------------------------------------------------

; Fix task in memory.

; Input:
;   BC = pointer to task name (6 chars)
; Returns:
;   CY flag set on error (e.g. task active)

;  T2.OUT  TA.FIX
;  ------  ------
;    0       0     task not in memory
;    0       1     task in memory and fixed
;    1       0     task not fixed and being loaded
;    1       1     task fixed and being loaded

$FIXTK:	call	$FNTSK		; find task
	ret	c		; return error if not found

	push	hl
	pop	ix		; get TCB into IX
	bit	TS.ACT,(ix+T.ST)
	ld	a,E.TACT	; return error if task is active
	scf
	ret	nz

	bit	TA.FIX,(ix+T.ATTR)
	ld	a,E.TFIX	; return error if task is already fixed
	scf
	ret	nz

FIX:	call	GETSIZ		; compute required space
	ret	c		; return error if task too big

	call	TALLOC		; allocate space for task
	ret	c		; return error if no available memory

	call	NEWCTX		; allocate and link new context block
	jp	c,trqe		; return if not enough pool memory

	xor	a
	ld	(ix+T.ST),a
	set	T2.OUT,a	; status = out of memory, all other bits = 0
	ld	(ix+T.ST+1),a

	set	TA.FIX,(ix+T.ATTR) ; set fixed attrib only after succesful
				   ;  TALLOC and NEWCTX

	xor	a
	ld	(ix+T.CPCB),a	; clear checkpoint PCB address
	ld	(ix+T.CPCB+1),a

	jp	trq6		; queue task to partition

;-----------------------------------------------------------------------

; Unfix task (remove from memory).

; Input:
;   BC = pointer to task name (6 chars)
; Returns:
;   CY flag set on error (e.g. task active)

$UNFTK:	call	$FNTSK		; find task
	ret	c		; error if not found

	push	hl
	pop	ix		; get TCB into IX
	bit	TS.ACT,(ix+T.ST)
	ld	a,E.TACT	; task active
	scf
	ret	nz

UNFIX:	bit	TA.FIX,(ix+T.ATTR)
	ld	a,E.TNFIX	; task not fixed
	scf
	ret	z
	res	TA.FIX,(ix+T.ATTR)

	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	ld	de,P.BASE
	add	hl,de
	ld	a,($SBANK)
	sub	(hl)		; task in kernel bank/partition?
	ret	z		; return success (A=0) if yes

	call	trqe0		; else release task mem and context block
	xor	a
	ret

;-----------------------------------------------------------------------

; Compute required task size from file size and information in TCB.

; Input:
;   IX = task TCB
; Returns:
;   E  = number of 4K pages to allocate.
;   CY set and error code in A if task image will not fit in memory.

GETSIZ:	ld	l,(ix+T.DEND)	; get default upper limit (task end addr + INC)
	ld	h,(ix+T.DEND+1)
	call	EA2PG		; convert to number of pages
	ld	e,a		; result in E
	or	a
	ld	a,E.BADTF
	scf			; size can't be zero
	ret	z
	ld	a,e
	cp	15+1		; max allowed size in pages
	ccf			;  (one page reserved for system common)
	ld	a,E.PBIG
	ret	c		; task won't fit in memory
	xor	a
	ret

; Compute number of 4K pages from upper address limit in HL.
; Return result in A. Preserves HL, DE, BC.

EA2PG:	push	hl
	push	de
	ld	de,4096		; bytes per page
	add	hl,de		; round to upper page boundary (note +4096
	ld	a,h		;  and not +4095 since size = end address + 1)
	rra			; divide by 4096
	rra			; note we're pushing the CY bit
	rra			;  from the addition back in
	rra
	and	1Fh
	pop	de
	pop	hl
	ret

;-----------------------------------------------------------------------

; Kill a task: remove task from active list, free task memory and
; optionally remove TCB from STD. Aborted tasks are reconnected to
; TKTN, which displays a message on the user console and emits abort
; status to parents.

; Input:
;   BC = valid task TCB address
;   E  = abort code, 0 for normal exit
; Returns:
;   CY flag set on error (e.g. task not active)

; TODO:
;   - ensure that all allocated resources are freed

TKILL:	call	CHKSYS
	ld	a,E.BADOP
	ret	c
	ld	hl,T.ST
	add	hl,bc
	bit	TS.ACT,(hl)	; task active?
	ld	a,E.TNAC
	scf
	ret	z		; error if not
	inc	hl
	bit	T2.ABO,(hl)	; task already being aborted?
	ld	a,E.TABO
	scf
	ret	nz		; return error if yes
	call	CLNDBG		; break any debug links
	push	de
	call	DISCON		; disconnect from offspring tasks
	push	bc
	call	CLRCVL		; purge receive list
	pop	ix
	call	CLRCMD		; purge command line
	push	ix
	ld	d,CT.MKT	; remove all mark time requests
	ld	e,0		; any event flag
	ld	bc,0		; any AST address
	call	CLNCLQ		; purge clock queue
	pop	bc
	call	IOKILL		; delete pending I/O requests
	pop	de
	or	e		; add outstanding I/O bit to reason code
	push	bc
	pop	ix
	ld	(ix+T.SVST),a	; use T.SVST as temp storage for reason code
	set	T2.ABO,(ix+T.ST+1) ; status = abort in progress
	push	ix
	call	CLNAST		; purge AST queue
	pop	bc
	call	$FNTCB		; find task in active list
	ret	c		; should not happen
	ld	a,(ix+T.ACTL)
	ld	(iy),a		; unlink TCB
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	push	bc
	ld	iy,$WLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move task to wait list
	pop	bc

	bit	T2.OUT,(ix+T.ST+1) ; task out of memory?
	jr	nz,tk6		   ; branch if yes

	bit	T2.CKP,(ix+T.ST+1) ; task (being) checkpointed?
	jr	z,tk5		   ; branch if not

tk6:	ld	e,(ix+T.PCB)
	ld	d,(ix+T.PCB+1)
	ld	hl,P.MAIN
	add	hl,de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	iy,P.WAIT
	add	iy,de		; TCB may be queued to the partition wait list
	ld	de,T.LNK
	call	UNLTCB		; so try to unlink it (returns IX=TCB)
	jr	nc,tk1		; branch on success

	ld	de,(LDRTCB)	; if not there, then it may be on the loader
	ld	a,d		;  queue
	or	e
	scf
	ret	z		; should not happen
	ld	iy,T.RCVL
	add	iy,de
	ld	de,T.LNK
	call	UNLTCB		; try to unlink it
	jr	nc,tk1		; branch on success

tk4:	bit	T2.LDR,(ix+T.ST+1) ; task aborted by loader?
	jr	nz,tk1		   ; branch if yes

	ld	e,c		; else is probably being processed by the
	ld	d,b		;  loader, so just return and finish abort
	ld	hl,($CTCB)	;   later
	call	CPDEHL		; current task?
	jp	z,SYSXIT	; then dispatch next
	xor	a		; else return success
	ret

tk1:	bit	T2.CKP,(ix+T.ST+1) ; task checkpointed?
	jr	z,tk5		   ; branch if not

	ld	l,(ix+T.CPCB)
	ld	h,(ix+T.CPCB+1)
	xor	a
	ld	(ix+T.CPCB),a
	ld	(ix+T.CPCB+1),a
	push	hl
	ex	(sp),ix
	push	hl
	call	FREECS		; free checkpoint space
	pop	hl
	ld	de,CPCBSZ
	call	$FREE		; free checkpoint PCB
	pop	ix

tk5:	ld	a,(ix+T.IOC)	; check I/O rundown count
	or	a
	jr	nz,tk4

	push	ix
	pop	hl		; get TCB address into HL
	ld	de,($CTCB)
	call	CPDEHL		; was it the current task?
	push	af		; save comparison result
	call	TKILL2
	pop	af		; was it the current task?
	jp	z,SYSXIT	; dispatch next task if yes
	xor	a
	ret

TKILL2:	; entry point from IODONE and loader routines

	push	ix
	pop	bc
	bit	TA.REM,(ix+T.ATTR) ; remove on exit?
	jr	z,tk0		; jump if not
	ld	iy,$TLIST
	ld	de,T.TCBL	; find task in STD
	call	FTCB		; IX=TCB, IY=prev
	ret	c		; should no happen
	ld	a,(ix+T.TCBL)	; else remove TCB from task directory
	ld	(iy),a
	ld	a,(ix+T.TCBL+1)
	ld	(iy+1),a
	res	TA.FIX,(ix+T.ATTR) ; and clear the 'fixed' attribute

tk0:	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	ret	c		; should not happen
	ld	a,(ix+T.ACTL)	; get link field into BC
	ld	(iy),a		; update link of previous TCB
	ld	a,(ix+T.ACTL+1)	;  (unlink TCB from active list)
	ld	(iy+1),a
	res	TS.ACT,(ix+T.ST); clear active bit

	ld	a,(ix+T.SVST)	; check abort code
	or	a		; normal exit?
	jr	z,tk3		; jump if yes
	ld	c,a
	push	ix
	call	QTKTN		; else post message to TKTN and request it
	pop	ix

tk3:	bit	TA.FIX,(ix+T.ATTR); task fixed in memory?
	jr	nz,tk31		  ; jump if yes, do not release memory

	call	FRECTX		; delete the context block
	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	ld	de,P.BASE
	add	hl,de
	ld	a,($SBANK)
	cp	(hl)		; task in kernel bank/partition?
	call	nz,TFREE	; release task memory if not (IX = TCB address)
	res	T2.OUT,(ix+T.ST+1)
	res	T2.CKP,(ix+T.ST+1)

tk31:	bit	TA.REM,(ix+T.ATTR); remove on exit?
	jr	z,tk2		; jump if not
	push	ix
	pop	hl		; get TCB address into HL
	ld	de,TCBSZ
	call	$FREE		; release TCB (already unlinked)
tk2:	xor	a		; otherwise return to caller
	ret

; Free the command line block.

CLRCMD:	ld	l,(ix+T.CMD)
	ld	h,(ix+T.CMD+1)
FRECMD:	ld	a,h		; get command line block address into HL
	or	l
	ret	z		; return if none
	ld	e,(hl)		; get length into DE
	ld	d,0
	inc	de		; +1 because size field
	push	ix
	call	$FREE
	pop	ix
	ret

; Delete the Task Context Block. Assumes any open files have been closed
; by the cleanup routine.

FRECTX:	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	ld	a,h
	or	l
	ret	z
	ld	de,CTXSZ
	push	ix
	push	bc
	call	$FREE		; free the context block
	pop	bc
	pop	ix
	xor	a
	ld	(ix+T.CTX),a	; clear pointer in TCB
	ld	(ix+T.CTX+1),a
	ret

; Return CY set if TCB in BC corresponds to one of the system tasks
; (LDR, MCR, but not TKTN or SYSFCP).

CHKSYS:	ld	hl,(MCRTCB)
	call	CPHLBC
	scf
	ret	z
	ld	hl,(LDRTCB)
	call	CPHLBC
	scf
	ret	z
	or	a
	ret

CPHLBC:	ld	a,b
	cp	h
	ret	nz
	ld	a,c
	cp	l
	ret

;-----------------------------------------------------------------------

; Remove a task from the STD. Task cannot be active, or an error occurs.

; Input:
;   BC = pointer to task name (6 chars)
; Returns:
;   CY flag set if task not found

$REMTK:	call	$FNTSK		; find task
	ret	c		; return error if not found
	ld	c,l
	ld	b,h
	ld	iy,$TLIST
	ld	de,T.TCBL
	call	FTCB		; IX=TCB, IY=prev
	ret	c		; should not happen
	bit	TS.ACT,(ix+T.ST); task active?
	ld	a,E.TACT
	scf
	ret	nz		; return error if yes
	push	ix
	push	iy
	call	UNFIX		; unfix and release memory if fixed
	pop	iy
	pop	ix
	ld	a,(ix+T.TCBL)	; remove TCB from task directory
	ld	(iy),a
	ld	a,(ix+T.TCBL+1)
	ld	(iy+1),a
	push	ix
	call	TCSRQ1		; remove any scheduled execution requests
	pop	hl		; TCB address now in HL
	ld	de,TCBSZ
	call	$FREE		; release TCB
	xor	a		; clear error flag
	ret			; and return

;-----------------------------------------------------------------------

; Stop a task.

; Input:
;   BC = TCB address
; Returns:
;   CY flag set if task not found
;   A = 0 on success
;   A = 1 if task already stopped

; TODO:
;   - check privileges.

TSTOP:	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	ret	c
	bit	TS.AST,(ix+T.ST); task in AST state?
	jr	nz,stp1		; jump if yes
	ld	a,(ix+T.ST)
	and	1 SHL TS.BPT	; check 'running' bits
	or	(ix+T.ST+1)	; is the task executing?
	jr	z,stp0		; skip next check if yes
	bit	T2.STP,(ix+T.ST+1) ; already stopped?
	ld	a,E.TSTP
	scf
	ret	nz		; if yes, return with 'already stopped' code
stp0:	ld	a,(ix+T.ACTL)	; get link field
	ld	(iy),a		; update link of previous TCB (unlink)
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$WLIST
	ld	bc,T.ACTL
	call	$LKTCB		; link task to waiting task list
	set	T2.STP,(ix+T.ST+1) ; set status bit
	xor	a		; return success
	ret

stp1:	bit	T2.STP,(ix+T.SVST+1) ; main thread already stopped?
	ld	a,E.TSTP
	scf
	ret	nz		; if yes, return with 'already stopped' code
	set	T2.STP,(ix+T.SVST+1) ; set status bit
	xor	a		; return success
	ret			; task will be stopped upon AST exit

;-----------------------------------------------------------------------

; Resume task.

; Input:
;   BC = TCB address
; Returns:
;   CY flag set if task not found
;   Z  flag set on success (task will become active if no other blocking
;      bits are set)
;   NZ if task not stopped (but not neccessarily running)

; TODO:
;   - check privileges

TRESUM:	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	ret	c
	bit	TS.AST,(ix+T.ST); task in AST state?
	jr	nz,res3		; jump if yes
	ld	a,(ix+T.ST+1)
	bit	T2.STP,a	; check stop bit
	jr	z,res1		; if not set, return error
	res	T2.STP,a	; else clear stop bit
	ld	(ix+T.ST+1),a
	or	a		; task now runnable?
	jr	nz,res2		; branch if not
	bit	TS.BPT,(ix+T.ST)
	jr	nz,res2
	ld	a,(ix+T.ACTL)	; get link field
	ld	(iy),a		; update link of previous TCB (unlink)
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$RLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move task to ready list
	xor	a
	ret

res1:	ld	a,E.TRUN
	or	a
	ret			; return NZ

res2:	res	T2.CKP,a	; checkpointed task...
	res	T2.OUT,a
	or	a		; ...became runnable?
	jp	z,TNEXT		; check partition wait list if yes
	xor	a		; else return success
	ret

res3:	bit	T2.STP,(ix+T.SVST+1) ; check saved stop bit
	ld	a,E.TRUN
	jr	z,res2		; if not set, return error
	res	T2.STP,(ix+T.SVST+1) ; else clear stop bit
	xor	a		; return success
	ret			; task will resume execution upon AST exit

;-----------------------------------------------------------------------

; Request task at specified time.

; Input:
;   HL = TDB address followed by relative schedule time and reschedule
;        interval.
; Returns:
;   CY flag set on error and error code in A

TSRUN:	call	CHKPRV		; check task privileges
	ret	c
	push	hl		; push TDB address
	ld	bc,TD.NAME
	add	hl,bc
	ld	c,l
	ld	b,h
	call	$FNTSK		; find task by name
	ex	de,hl		; get TCB address into DE
	pop	bc		; pop TDB address
	ret	c
	ld	hl,TDBSZ
	add	hl,bc		; point to time parameters
	jp	SRQST		; queue request

;-----------------------------------------------------------------------

; Cancel scheduled task request.

; Input:
;   IX = TCB address
; Returns:
;   CY flag set on error and error code in A

TCSRQ:	call	CHKPRV		; check task privileges
	ret	c
TCSRQ1:	ld	d,CT.RUN	; cancel all scheduled run requests
	ld	e,0
	ld	bc,0
	jp	CLNCLQ		; remove requests from clock queue

;-----------------------------------------------------------------------

; Wakeup the specified task. Usually called upon setting an event flag.

; Input:
;   BC = TCB address
; Returns:
;   CY flag set if task not found
;   Z  flag set on success (task will become active if no other blocking
;      bits are set)
;   NZ if task not stopped (but not neccessarily running)

TCONT:	call	$FNTCB		; find task in active list: IX=TCB, IY=prev
	ret	c
	ld	a,(ix+T.ST+1)
	bit	T2.EFW,a	; task waiting for flag?
	jr	z,tc1		; branch if not
	res	T2.EFW,a	; else clear the corresponding status bit
	jr	tc2
tc1:	bit	T2.SEF,a	; task stopped for flag?
	jr	z,tc3		; return error (NZ) if not
	res	T2.SEF,a	; else clear the corresponding status bit
tc2:	ld	(ix+T.ST+1),a
	or	a		; task became runnable?
	jr	nz,tc4		; branch if not
	bit	TS.BPT,(ix+T.ST)
	jr	nz,tc5
	ld	a,(ix+T.ACTL)	; get link field
	ld	(iy),a		; update link of previous TCB (unlink)
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$RLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move task to ready list
tc5:	xor	a		; return success
	ret

tc3:	ld	a,E.TRUN
	or	a
	ret			; return NZ

tc4:	res	T2.CKP,a	; checkpointed task...
	res	T2.OUT,a
	or	a		; ...became runnable?
	jp	z,TNEXT		; check partition wait list if yes
	xor	a		; else return success
	ret

;-----------------------------------------------------------------------

; Change the priority of a task.

; Input:
;   BC = TCB address
;   E  = new priority, zero to reset priority to default value
;   D  = which priority to set: 0 = running, 1 = installed
; Returns:
;   CY flag set on error and error code in A

; If the current task changes its priority to a lower value it may be
; immediately preempted. If the current task gives another task a
; higher priority than its own, the current task will be immediately
; preempted.

ALTPRI:	ld	hl,T.DPRI
	add	hl,bc
	ld	a,e
	or	a		; reset priority to default?
	jr	nz,altp1	; jump if not
	ld	e,(hl)
	jr	altp2

altp1:	ld	a,(hl)
	cp	e		; is new priority higher than default?
	jr	c,altp3		; jump if yes, task must be privileged

altp2:	ld	a,d
	or	a		; altering default priority?
	jr	nz,altp3	; jump if yes, task must be privileged

	ld	hl,($CTCB)	; changing priority of another task?
	ld	a,h
	cp	b
	jr	nz,altp3
	ld	a,l
	cp	c
	jr	z,altp4		; jump if not

altp3:	call	CHKPRV		; else current task must be privileged
	ret	c		; return error if not

altp4:	ld	a,d
	or	a		; change running priority only?
	jr	z,altp5		; jump if yes

	push	de
	push	bc
	ld	iy,$TLIST
	ld	de,T.TCBL	; search STD
	call	FTCB		; IX=TCB, IY=prev
	pop	bc
	pop	de
	ret	c		; return error if task not found
	ld	(ix+T.PRI),e	; set new running priority
	ld	(ix+T.DPRI),e	; and also the default priority
	ld	a,(ix+T.TCBL)	; remove TCB from task directory
	ld	(iy),a
	ld	a,(ix+T.TCBL+1)
	ld	(iy+1),a
	push	de
	push	bc
	ld	iy,$TLIST
	ld	bc,T.TCBL
	call	$LKTCB		; reinsert TCB according to new priority
	pop	bc
	pop	de

altp5:	push	de
	push	bc
	ld	iy,$RLIST
	ld	de,T.ACTL
	call	FTCB		; search running task list
	pop	bc
	pop	de
	jr	c,altp6		; jump if not found here
	ld	(ix+T.PRI),e	; set running priority
	ld	a,(ix+T.ACTL)	; remove TCB from ready list
	ld	(iy),a
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$RLIST
	ld	bc,T.ACTL
	call	$LKTCB		; reinsert TCB according to new priority
	xor	a
	ret

altp6:	push	de
	push	bc
	ld	iy,$WLIST
	ld	de,T.ACTL
	call	FTCB		; last, search waiting list
	pop	bc
	pop	de
	jr	c,altp7		; jump if not found here
	ld	(ix+T.PRI),e	; set running priority
	ld	a,(ix+T.ACTL)	; remove TCB from waiting list
	ld	(iy),a
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$WLIST
	ld	bc,T.ACTL
	call	$LKTCB		; reinsert TCB according to new priority
altp7:	xor	a
	ret

;-----------------------------------------------------------------------

; Switch the current (privileged) task to supervisor mode.

; The supervisor mode maps the kernel data area into the task's memory
; space, allowing access to the system database structures.

; Input:
;   --
; Returns:
;   A = 0 on success
;   A = error code if not enough privileges 

TSETSV:	ld	ix,($CTCB)
	xor	a
	bit	TS.SUP,(ix+T.ST)
	ret	nz		; already in supervisor mode
	bit	TA.PRV,(ix+T.ATTR)
	ld	a,E.PRIV
	scf
	ret	z		; not a privileged task
	set	TS.SUP,(ix+T.ST)
	xor	a
	ret

;-----------------------------------------------------------------------

; Switch back the current task memory mapping to user mode.

; Input:
;   --
; Returns:
;   A = 0 on success (always)

TCLRSV:	ld	ix,($CTCB)
	res	TS.SUP,(ix+T.ST)
	xor	a
	ret

;-----------------------------------------------------------------------

; Find a task by name in the STD list and return its TCB address.

; Input:
;   BC = addr of task name (6 chars)
; Returns:
;   HL = task TCB address
;   CY flag set if task cannot be found.

; Note: Call this function only when in system level (SYSLVL=-1) to
; prevent race conditions.

$FNTSK:	ld	hl,$TLIST
FTSK:	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	dec	hl
	ex	de,hl		; DE=prev, HL=next
	ld	a,h
	or	l
	ld	a,E.TNF		; 'task not found' error
	scf
	ret	z
	push	bc
	push	hl
	ld	de,T.NAME	; name offset
	add	hl,de
	ld	d,6		; name length
ftsk2:	ld	a,(bc)
	cp	(hl)
	jr	nz,ftsk3	; jump if no match
	inc	hl
	inc	bc
	dec	d
	jr	nz,ftsk2	; loop unitl all chars processed
	pop	hl		; found, return this TCB
	pop	bc
	xor	a
	ret
ftsk3:	pop	hl
	ld	bc,T.TCBL
	add	hl,bc
	pop	bc
	jr	FTSK

;-----------------------------------------------------------------------

; Locate the TCB of the task in the active list and return list
; pointers for subsequent insert/remove operations.

; Input:
;   BC = task TCB address
; Returns:
;   IX = TCB address
;   IY = addr of *link* field on prev TCB
;   CY flag set if the task cannot be found.
; Preserves BC

; Notes:
; - Should be called with SYSLVL=-1 (otherwise with interrupts disabled).

$FNTCB:	ld	de,T.ACTL
	ld	iy,$RLIST
	call	FTCB
	ret	nc
	ld	iy,$WLIST
FTCB:	ld	l,(iy)		; get link value into HL
	ld	h,(iy+1)
	ld	a,h		; zero?
	or	l
	ld	a,E.TNF
	scf			; then return with error (TCB not found)
	ret	z
	ld	a,l
	cp	c		; compare TCB addresses
	jr	nz,fndt1
	ld	a,h
	cp	b
	jr	nz,fndt1
	push	hl
	pop	ix		; if match, get TCB address into IX
	xor	a		; and return success
	ret
fndt1:	add	hl,de		; else add link offset (T.LNK, T.TCBL or T.ACTL)
	push	hl
	pop	iy		; move TCB address to IY
	jr	FTCB		; and loop

; Unlink TCB from a list

; Input:
;   BC = task TCB address
;   DE = offset to link field in TCB (T.LNK, T.ACTL or T.TCBL)
;   IY = address of list head pointer
; Returns:
;   IX = TCB address
;   CY flag set if the task cannot be found.
; Preserves BC

UNLTCB:	call	FTCB
	ret	c
	add	hl,de
	ld	a,(hl)
	ld	(iy),a
	inc	hl
	ld	a,(hl)
	ld	(iy+1),a
	ret

;-----------------------------------------------------------------------

; Allocate (sub)partition control block for task.

; Input:
;   IX = TCB
;   E  = requested task size in pages
; Returns:
;   D  = task bank number
;   E  = number of allocated pages
;   CY set on error

TALLOC:	ld	a,e		; get requested number of pages
	cp	15+1		; should be in the 00-0F range (0000-EFFF)
	ccf
	ld	a,E.NOMEM
	ret	c		; prevent overwriting the commom segment
	ld	l,(ix+T.PCB)	; get pointer to partition
	ld	h,(ix+T.PCB+1)
	ld	bc,P.MAIN
	add	hl,bc
	ld	a,(hl)		; get pointer to main partition
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl
	pop	iy		; IY = main PCB
	bit	PA.SYS,(iy+P.ATTR) ; system-controlled partition?
	jr	nz,ta1		; jump if yes

	; task partition [TODO: merge with MALLOC in pars.mac?]

	xor	a
	ret

ta1:	; system-controlled partition

	push	ix		; save TCB address
	call	NEWSUB		; create new sub PCB
	pop	bc
	ret	c		; return if out of pool memory
	push	ix
	pop	iy		; IY = sub PCB
	push	bc
	pop	ix		; IX = TCB
	ld	e,(iy+P.SIZE)
	ld	d,(iy+P.BASE)
	push	iy
	pop	bc
	ld	(ix+T.PCB),c	; set pointer to subpartition PCB in TCB
	ld	(ix+T.PCB+1),b
	push	ix
	pop	bc
	ld	(iy+P.TCB),c	; set pointer to TCB in subpartition PCB
	ld	(iy+P.TCB+1),b
	xor	a		; return success
	ret

;-----------------------------------------------------------------------

; Release task memory.

; The task must have been killed, the TCB is unlinked but still contains
; valid data. The subpartition PCB is freed and memory assigned to the
; next task.

; Input:
;   IX = TCB
; Preserves IX.

TFREE:	ld	e,(ix+T.PCB)
	ld	d,(ix+T.PCB+1)
	push	de
	ex	(sp),ix		; push TCB, pop PCB
	ld	l,(ix+P.MAIN)	; get pointer to main PCB
	ld	h,(ix+P.MAIN+1)
	push	hl
	pop	iy
	bit	PA.SYS,(iy+P.ATTR) ; system-controlled partition?
	jr	nz,tf1		; jump if yes

	; task partition [TODO: merge with MALLOC in pars.mac?]

	res	PS.BSY,(iy+P.STAT)
	jr	tf2		; continue via common code

tf1:	; system-controlled partition

	push	hl
	call	MFREE		; release task memory
	push	ix
	pop	hl
	ld	de,PCBSZ
	call	$FREE		; free subpartition PCB
	pop	hl
tf2:	pop	ix
	ld	(ix+T.PCB),l	; replace subpartition PCB with main PCB
	ld	(ix+T.PCB+1),h
	push	ix
	push	hl
	pop	iy
	call	$ASNTP		; assign next task to partition
	pop	ix
	xor	a
	ret

;-----------------------------------------------------------------------

; Extend task size.

; Input:
;   IX = task TCB
;   HL = positive or negative increment in 16-byte units,
;        or zero to restore installed task size.
; Returns:
;   CY set on error and error code in A.

; TODO:
; - return error if task has outstanding I/O and new size caused either
;   the task to shrink, or to relocate to a new region.

EXTTSK:	call	newtop		; compute new task's top address
	ret	c		; on error, return
	ld	e,(ix+T.DEND)
	ld	d,(ix+T.DEND+1)
	call	CPDEHL		; new end below the default (installed) end?
	ld	a,E.BADOP
	ret	c		; error if yes
	call	EA2PG		; compute new size in pages
	ld	e,a		; save it in E
	push	hl
	ld	c,(ix+T.PCB)	; get subpartition PCB address
	ld	b,(ix+T.PCB+1)
	ld	hl,P.SIZE
	add	hl,bc
	cp	(hl)		; same number of pages as before?
	pop	hl
	jp	z,stend		; if yes, set new end address and return
	ld	a,e
	cp	15+1		; max allowed number of pages is 15
	ccf
	ld	a,E.NOMEM
	ret	c		; prevent overwriting the commom segment
	ld	a,e
	or	a
	ld	a,E.INV
	scf
	ret	z		; zero size is illegal

	push	hl		; remember new end address
	push	de		; remember new size in pages
	push	bc
	ex	(sp),ix		; IX now has subpartition PCB address
	ld	b,(ix+P.BASE)	; remember old subpartition base
	push	bc
	call	MEXTND		; extend partition
	pop	bc
	ld	d,(ix+P.BASE)	; get new base
	pop	ix		; pop TCB address back into IX
	jr	c,tryckp	; if extend failed, try checkpointing task

	pop	hl		; discard new size
	ld	a,d
	cp	b		; partition relocated?
	jr	z,stend1	; no, set new end address and return success

	push	de		; save new base ($UBANK)
	di
	ld	a,d
	exx
	ld	e,a		; E' = dst bank
	exx
	ld	a,b
	exx
	ld	l,a		; L' = src bank
	exx
	ld	hl,0
	ld	de,0
	ld	c,(ix+T.END)
	ld	b,(ix+T.END+1)
	inc	bc		; move size = old end address - 1
	call	$MCOPY		; re-locate task to new region
	ei
	ld	hl,($CTCB)
	push	ix
	pop	de
	call	CPDEHL
	pop	de		; restore new base
	jr	nz,stend1
	ld	a,d
	ld	($UBANK),a	; update $UBANK if necessary
	jr	stend1

tryckp:	; try checkpointing task until memory becomes available

	IF	F$CHKP

	extrn	$CHKPT

	pop	de		; restore new size
	ld	a,(ix+T.IOC)
	or	a		; task has outstanding I/O?
	ld	a,E.BADOP
	scf
	jr	nz,exte1	; yes, can't checkpoint

	ld	l,(ix+T.PCB)
	ld	h,(ix+T.PCB+1)
	push	hl
	pop	iy		; IY = subpartition PCB address

	ld	l,(iy+P.MAIN)	; get main partition address
	ld	h,(iy+P.MAIN+1)
	ld	de,P.SIZE
	add	hl,de
	ld	a,(hl)		; get size of main partition
	cp	e
	ld	a,E.NOMEM	; don't checkpoint task if it became larger
	jr	c,exte1		;  than the main partition

	push	iy
	push	ix
	call	$CHKPT		; try to checkpoint task
	pop	ix
	pop	iy
	jr	c,exte1		   ; no can do
	bit	T2.CKP,(ix+T.ST+1) ; checkpoint initiatted?
	jr	nz,stend1	   ; yes, success
	res	TS.CKR,(ix+T.ST)   ; paranoia
	ld	a,E.NOMEM	   ; no
	scf
exte1:	pop	hl
	ret			; return error

	ELSE

	pop	de		; checkpointing not supported
	pop	hl
	ld	a,E.NOMEM	; return error
	scf
	ret

	ENDIF

stend1:	pop	hl
stend:	ld	(ix+T.END),l	; set new task end
	ld	(ix+T.END+1),h
	xor	a
	ret			; return success

newtop:	ld	e,(ix+T.END)	; get current task end address into DE
	ld	d,(ix+T.END+1)
	ld	a,h
	or	a		; check sign
	jp	m,shrink	; if negative, shrink task
	or	l
	jr	nz,expand	; if positive, expand task
	ld	l,(ix+T.DEND)	; if zero, restore installed size
	ld	h,(ix+T.DEND+1)
	ret			; return with CY clear

expand:	call	bytesz		; convert increment to bytes
	ld	a,E.NOMEM
	ret	c		; error increment > 64K
	add	hl,de
	ret

shrink:	ld	a,h
	cpl
	ld	h,a
	ld	a,l
	cpl
	ld	l,a
	inc	hl		; get absolute value
	call	bytesz		; convert decrement to bytes
	ld	a,E.INV
	ret	c		; error if decrement > 64K
	ex	de,hl
	sbc	hl,de
	ret

bytesz:	add	hl,hl		; *2
	ret	c
	add	hl,hl		; *4
	ret	c
	add	hl,hl		; *8
	ret	c
	add	hl,hl		; *16
	ret

;-----------------------------------------------------------------------

; Check if current task is privileged.

; Input:
;   $CTCB = TCB of current task
; Output:
;   CY flag set and error code in A if task not privileged.

CHKPRV:	push	hl
	push	de
	call	cktp1
	pop	de
	pop	hl
	ret

cktp1:	ld	hl,($CTCB)
	ld	a,h
	or	l
	ret	z
	ld	de,T.ATTR
	add	hl,de
	bit	TA.PRV,(hl)
	ret	nz
	ld	a,E.PRIV
	scf
	ret			; return error if not

;-----------------------------------------------------------------------

; Connect debugger to an external task.

; Input:
;   $CTCB = debugger TCB address
;   BC    = TCB address of task to debug
;   E     = optional event flag number to set on debug events
;   HL    = address of debug status block in user space
; Output:
;   CY flag set and error code in A.

$DBCON:	call	CHKPRV		; the issuing task must be privileged
	ret	c
	push	bc		; push TCB address of task to debug
	push	de		; push event flag number
	push	hl		; push DSB address
	ld	iy,$TLIST
	ld	de,T.TCBL
	call	FTCB		; locate task
	jr	c,dc1
	bit	TS.ACT,(ix+T.ST); task active?
	ld	a,E.TNAC
	jr	z,dc1		; no, error

	ld	hl,($CTCB)
	push	ix
	pop	de
	call	CPDEHL
	ld	a,E.BADOP
	jr	z,dc1		; can't debug itself

	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	ld	a,h
	or	l		; paranoia check
	ld	a,E.TNAC
	jr	z,dc1

	ld	bc,TX.XDT
	add	hl,bc
	ld	a,(hl)		; check task's TX.XDT
	inc	hl
	or	(hl)		; task already attached to a debugger?
	dec	hl
	ld	a,E.INV
	jr	nz,dc1		; yes, error

	push	hl		; push TX.XDT address
	ld	bc,XDTSZ
	call	$ALLOC		; allocate debugger data block
	pop	de		; pop TX.XDT address into DE
	jr	c,dc1

	ex	de,hl
	ld	(hl),e		; set task's TX.XDT
	inc	hl
	ld	(hl),d
	push	de
	pop	ix		; IX = addr of debug context block

	ld	hl,($CTCB)
	ld	(ix+XD.TCB),l	; set XD.TCB to the issuing task
	ld	(ix+XD.TCB+1),h
	pop	de		; pop DSB address
	ld	(ix+XD.DSB),e	; set XD.DSB
	ld	(ix+XD.DSB+1),d
	pop	de		; pop event flag number
	ld	(ix+XD.EFN),e	; set XD.EFN
	xor	a
	ld	(ix+XD.AST),a	; XD.AST not yet supported
	ld	(ix+XD.AST+1),a

	push	hl
	pop	ix		; IX = TCB address of debugger
	set	TS.XDT,(ix+T.ST); set TS.XDT status bit on issuing task
	pop	de		; pop TCB address of task to debug
	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	ld	bc,TX.XDT
	add	hl,bc
	ld	(hl),e		; store it in debugger's TX.XDT
	inc	hl
	ld	(hl),d
	xor	a		; return success
	ret

dc1:	pop	hl
	pop	de
	pop	bc
	scf
	ret

; Disconnect from task and free debug context block.
;
; Input:
;   BC = TCB address of debugged task
; Output:
;   CY flag set and error code in A.

$DBDIS:	call	$DBRES		; resume task execution
	ret	c		; should not happen
	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	ld	de,TX.XDT
	add	hl,de
	ld	e,(hl)		; get pointer to debugger context block
	inc	hl
	ld	d,(hl)
	dec	hl
	ld	a,d
	or	e		; debugger attached?
	ld	a,E.INV
	scf
	ret	z		; no, return error
	push	hl		; push address of TX.XDT field
	ld	a,(hl)		; get TX.XDT into HL
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	bc,XD.TCB
	add	hl,bc
	ld	a,(hl)		; get debugger TCB address into HL
	inc	hl
	ld	h,(hl)
	ld	l,a
	push	hl		; push TCB address of debugger
	ex	de,hl		; HL = pointer to debugger context block
	ld	de,XDTSZ
	call	$FREE		; free debugger data block
	pop	ix		; pop TCB address of debugger
	pop	hl		; pop address of TX.XDT field
	xor	a
	ld	(hl),a		; clear TX.XDT
	inc	hl
	ld	(hl),a
	res	TS.XDT,(ix+T.ST); clear debugger's TS.XDT bit
	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	ld	de,TX.XDT
	add	hl,de
	ld	(hl),a		; clear debugger's TX.XDT too
	inc	hl
	ld	(hl),a
	xor	a		; return success
	ret

; Break task execution: set TS.BPT bit and move the task to the waiting
; list.
;
; Input:
;   BC = TCB address of debugged task
; Output:
;   IX = TCB address of debugged task
;   CY flag set and error code in A.

; TODO: notify debugger?

$DBBRK:	ld	hl,T.ST
	add	hl,bc
	bit	TS.BPT,(hl)	; task already stopped at breakpoint?
	ld	a,E.TSTP
	scf
	ret	nz		; yes, return
	set	TS.BPT,(hl)	; set TS.BPT bit
	ld	hl,T.SVST
	add	hl,bc
	set	TS.BPT,(hl)	; also in T.SVST in case task is in AST mode
	call	$FNTCB
	ret	c		; should not happen
	ld	a,(ix+T.ACTL)
	ld	(iy),a		; unlink
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$WLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move task to waiting list
	xor	a		; return success
	ret

; Resume task execution: clear TS.BPT bit and (eventually) move the task
; to the ready list.
;
; Input:
;   BC = TCB address of debugged task
; Output:
;   IX = TCB address of debugged task
;   CY flag set and error code in A.

$DBRES:	ld	hl,T.ST
	add	hl,bc
	res	TS.BPT,(hl)	; clear TS.BPT bit
	ld	hl,T.SVST
	add	hl,bc
	res	TS.BPT,(hl)	; also in T.SVST in case task is in AST mode
	call	$FNTCB
	ret	c		; should not happen
	ld	a,(ix+T.ST+1)
	or	a		; task became runnable?
	ret	nz		; no
	ld	a,(ix+T.ACTL)
	ld	(iy),a		; unlink
	ld	a,(ix+T.ACTL+1)
	ld	(iy+1),a
	ld	iy,$RLIST
	ld	bc,T.ACTL
	call	$LKTCB		; move task to ready list
	xor	a
	ret

; Notify debugger of a debugging event.
;
; Input:
;   IX = valid TCB address of the debugged task
;   BC = event code
;   DE = additional info (e.g. status code on task exit)
; Output:
;   IX = TCB address of debugged task
;   CY flag set and error code in A.

	extrn	SDINFO,TMPST

$DBNOT:	ld	l,(ix+T.CTX)	; get task context address
	ld	h,(ix+T.CTX+1)
	push	hl
	pop	iy
	ld	l,(iy+TX.XDT)	; get TX.XDT address
	ld	h,(iy+TX.XDT+1)
	ld	a,h
	or	l		; safety check
	ld	a,E.INV		; error if no debugger attached
	scf
	ret	z
	
	push	hl
	pop	iy		; IY = TX.XDT address
	ld	l,(iy+XD.TCB)
	ld	h,(iy+XD.TCB+1)
	ld	a,h
	or	l		; safety check
	ld	a,E.INV		; error if no debugger attached
	scf
	ret	z

	ld	(TMPST),bc
	ld	(TMPST+2),de
	push	hl
	pop	ix		; IX = XD.TCB
	ld	l,(iy+XD.DSB)
	ld	h,(iy+XD.DSB+1)
	ld	bc,4		; length of data
	ld	a,AST.DB	; AST type code
	push	iy
	call	SDINFO		; store info and optionally queue AST
	pop	iy
	push	ix
	pop	bc		; BC = XD.TCB
	ld	e,(iy+XD.EFN)
	ld	a,e
	or	a
	call	nz,SETFLG	; set event flag for debugger
	xor	a		; return success
	ret

; Break debugger connections in case a debugger or a debugged task aborts:
;
; - if a connected debugger (TS.XDT status bit set) aborts, disconnect from
;   the debugged task, free the corresponding TX.XDT block and resume the
;   execution of the debugged task (note: any breakpoints left set by the
;   debugger may cause the debugged task to abort)
;
; - if the debugged task (TX.XDT is non-zero) aborts, free the TX.XDT block
;   and notify the debugger.
;
; Input:
;   BC = valid task TCB address
;   E = abort code, 0 for normal exit

CLNDBG:	push	bc
	pop	ix
	bit	TS.XDT,(ix+T.ST); connected debugger?
	jr	nz,dbc1		; yes
	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	push	de
	ld	de,TX.XDT
	add	hl,de
	pop	de
	ld	a,(hl)		; task being debugged?
	inc	hl
	or	(hl)
	ret	z		; no, return

	push	de
	push	bc
	ld	c,80h
	ld	b,e
	call	dbc2
	call	$DBNOT		; notify debuger about task abort
	pop	bc
	push	bc
	call	$DBDIS		; disconnect from debugger
	pop	bc
	pop	de
	ret

dbc1:	push	de
	push	bc
	ld	l,(ix+T.CTX)
	ld	h,(ix+T.CTX+1)
	ld	bc,TX.XDT
	add	hl,bc
	ld	c,(hl)
	inc	hl
	ld	b,(hl)
	ld	a,b
	or	c
	call	nz,$DBDIS	; disconnect and resume execution of the
	pop	bc		;  debugged task
	pop	de
	ret

dbc2:	inc	b
	dec	b
	ld	de,0
	ret	nz
	ld	de,(TMPST)	; hack!
	ret

	END
